<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jason McCoy - Portfolio - Principal Product Designer</title>
    <meta name="description" content="Jason McCoy is a Principal Product Designer and Product Manager who specializes in building B2B SaaS products with complex workflows, B2C consumer finance applications, and B2B enterprise software. He is a 5x founding designer and 1x founder with an exit. He excels in market analysis and identifying unspotted opportunities to deliver customer value and drive business growth.">
    <meta name="keywords" content="Jason McCoy, Product Designer, Portfolio, Principal Product Designer, Product Design, Product Development, Product Management, Product Strategy, Product Marketing, Product Analytics, Product Research, Product Strategy, Product Roadmap, Product Planning, Product Execution, Product Development, Product Management, Product Strategy, Product Marketing, Product Analytics, Product Research, Product Strategy, Product Roadmap, Product Planning, Product Execution">
    <meta name="author" content="Jason McCoy">
    <meta name="robots" content="noindex, nofollow, noarchive, nosnippet, noimageindex, nocache">
    <meta name="googlebot" content="noindex, nofollow, noarchive, nosnippet, noimageindex">
    <meta name="bingbot" content="noindex, nofollow, noarchive, nosnippet, noimageindex">
    <meta name="slurp" content="noindex, nofollow, noarchive, nosnippet, noimageindex">
    <meta name="duckduckbot" content="noindex, nofollow, noarchive, nosnippet, noimageindex">
    <meta name="Baiduspider" content="noindex, nofollow, noarchive, nosnippet, noimageindex">
    <meta name="YandexBot" content="noindex, nofollow, noarchive, nosnippet, noimageindex">
    <meta name="google" content="notranslate">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <link rel="icon" type="image/png" href="./images/favicon.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Archivo+Black&family=Jost:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <nav class="nav">
        <div class="nav-left">
            <a href="https://www.loom.com/share/9db28bc632f442c6bb9a6cd6cd6ac8d6?sid=fba0a2a2-b744-4b97-a9a4-4a985e665ba6" class="nav-link" target="_blank" rel="noopener noreferrer">Intro video</a>
            <a href="https://www.figma.com/proto/K0YaaAOtqvCgeLE9Vulmtn/Jason-McCoy?page-id=49723%3A18804&node-id=51493-80988&viewport=6190%2C6768%2C0.06&t=VEoNbFbGLLtdqIRR-1&scaling=contain&content-scaling=fixed&starting-point-node-id=51493%3A80988&show-proto-sidebar=1" class="nav-link" target="_blank" rel="noopener noreferrer">Onsite deck</a>
        </div>
        <h1 class="name-nav">JASON MCCOY</h1>
        <div class="nav-right">
            <a href="jason-mccoy-resume.pdf" class="nav-link" target="_blank" rel="noopener noreferrer">Résumé</a>
            <a href="https://www.linkedin.com/in/principal-product-designer/" class="nav-link" target="_blank" rel="noopener noreferrer">LinkedIn</a>
        </div>
    </nav>

    <div class="dots-overlay" id="dots-overlay"></div>

    <main class="main">
        <section class="hero">
            <h1 class="name">JASON MCCOY</h1>
        </section>

        <section class="triangle-section">
            <div class="triangle-container">
                <div class="triangle-label triangle-label-top">Product</div>
                <svg class="triangle" viewBox="0 0 400 400" preserveAspectRatio="xMidYMid meet">
                    <polygon points="200,50 50,350 350,350" fill="none" stroke="rgba(207, 189, 255, 0.3)" stroke-width="1"/>
                </svg>
                <img src="images/jason-mccoy.png" alt="Jason McCoy" class="profile-picture initial-load">
                <div class="triangle-label triangle-label-bottom-left">Design</div>
                <div class="triangle-label triangle-label-bottom-right">Engineering</div>
                <div class="triangle-label triangle-label-center">Principal Product Builder</div>
            </div>
        </section>

        <section class="bio-section">
            <div class="bio-container">
                <div class="testimonial-text">
                    <p class="bio-text">Jason is one of the best designers I've worked with. He combines user understanding, business judgment, and technical fluency in a way that's rare. His designs are not just polished but grounded in how real products work and scale.</p>
                    <p class="bio-text">He thinks in systems, not screens, and approaches every decision with clear reasoning and practicality. He understands trade-offs and moves quickly without compromising on quality.</p>
                    <p class="bio-text">Jason operates at the level of a director. A UX-centric product manager who can connect design, engineering, and business to deliver products that matter.</p>
                </div>
                <div class="testimonial-attribution">
                    <img src="images/jaimin.png" alt="Jamin Gandhi" class="testimonial-photo">
                    <div class="testimonial-author">
                        <div class="testimonial-name">Jamin Gandhi</div>
                        <div class="testimonial-title">VP Product</div>
                        <div class="testimonial-credentials">ex-Uber, ex-Binance</div>
                    </div>
                </div>
            </div>
        </section>

        <section class="project">
            <h2 class="project-title">Tuttle</h2>
            <p class="project-description">
                I met an attorney in my hometown who wanted to bootstrap a B2B SaaS that automates medical records for personal injury law practices. I led customer and product discovery, brought in the engineering team, and secured the first six customers.
            </p>
            <div class="project-tags">
                <span class="tag">2025</span>
                <span class="tag">B2B</span>
                <span class="tag">PM</span>
                <span class="tag">Discovery</span>
                <span class="tag">GTM</span>
                <span class="tag">AI</span>
            </div>
            <div class="screenshot-container horizontal-scroll">
                <div class="screenshot-scroll-wrapper">
                    <div class="iframe-wrapper">
                        <iframe id="tuttle-iframe" src="https://tuttle-discovery-prototype.netlify.app/login" width="1124" height="710" frameborder="0" style="border-radius: 8px; overflow: hidden; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3); background-color: #000;"></iframe>
                        <audio id="tuttle-audio" preload="metadata">
                            <source src="images/tuttle-audio.m4a" type="audio/mp4">
                        </audio>
                        <div class="audio-player">
                            <button class="audio-play-button" id="audio-play-button" aria-label="Play audio">
                                <svg class="play-icon" width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M6 4L6 16L14 10L6 4Z" fill="currentColor"/>
                                </svg>
                                <svg class="pause-icon" width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg" style="display: none;">
                                    <rect x="6" y="4" width="3" height="12" fill="currentColor"/>
                                    <rect x="11" y="4" width="3" height="12" fill="currentColor"/>
                                </svg>
                            </button>
                            <button class="audio-reset-button" id="audio-reset-button" aria-label="Reset audio" title="Reset audio to start" disabled>
                                <img src="images/arrow-counter-clockwise.svg" alt="Reset" width="20" height="20">
                            </button>
                            <div class="audio-time" id="audio-time">0:00/0:00</div>
                        </div>
                        <div class="login-tooltip" id="login-tooltip">
                            <div class="tooltip-content">
                                <button class="tooltip-close" id="tooltip-close" aria-label="Close login credentials">
                                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                                        <path d="M12 4L4 12M4 4L12 12" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                                    </svg>
                                </button>
                                <div class="tooltip-title">Login Credentials</div>
                                <div class="tooltip-credential">
                                    <span class="credential-label">Email:</span>
                                    <span class="credential-value">jason+1@tuttle.work</span>
                                </div>
                                <div class="tooltip-credential">
                                    <span class="credential-label">Password:</span>
                                    <span class="credential-value">hahaha</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <img src="images/tuttle-dashboard.png" alt="Tuttle Dashboard" class="screenshot">
                    <img src="images/new-request.png" alt="New Request" class="screenshot">
                    <img src="images/request-details.png" alt="Request Details" class="screenshot">
                    <img src="images/provider-details.png" alt="Tuttle Provider Details" class="screenshot">
                    <img src="images/add-provider.png" alt="Add Providers" class="screenshot">
                </div>
            </div>
        </section>

        <section class="project">
            <h2 class="project-title">Nerdy</h2>
            <p class="project-description">
                As Principal Product Designer, I acted as Product Manager and Design Lead, using generative AI to prototype data-driven production-quality prototypes for executive alignment and discovery research with online academic tutors.
            </p>
            <div class="project-tags">
                <span class="tag">2025</span>
                <span class="tag">Marketplace</span>
                <span class="tag">AI</span>
                <span class="tag">Product Management</span>
                <span class="tag">Discovery</span>
                <span class="tag">Design Engineering</span>
            </div>
            <div class="video-container">
                <img id="video-placeholder" src="images/nerdy-session-prep.png" alt="Nerdy Session Prep" class="video-placeholder-image">
                <video id="nerdy-video" class="video-player-element" preload="none" controls style="display: none;">
                    <source src="images/nerdy-tutors.mp4" type="video/mp4">
                    Your browser does not support the video tag.
                </video>
                <button class="video-play-button" id="video-play-button" aria-label="Play video">
                    <svg width="80" height="80" viewBox="0 0 80 80" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <circle cx="40" cy="40" r="40" fill="#392A47"/>
                        <path d="M32 24L32 56L56 40L32 24Z" fill="#FFFFFF"/>
                    </svg>
                </button>
            </div>
        </section>

        <section class="project">
            <h2 class="project-title">Dropbox Replay</h2>
            <p class="project-description">
                I joined a 10-person team to build a video review and feedback tool for creatives, leading design from alpha to general availability, reaching $2m ARR the first year after launch.
            </p>
            <div class="project-tags">
                <span class="tag">2022</span>
                <span class="tag">B2C</span>
                <span class="tag">0→1</span>
            </div>
            <div class="screenshot-container horizontal-scroll">
                <div class="screenshot-scroll-wrapper">
                    <img src="images/replay-demo.png" alt="Dropbox Replay Feedback View" class="screenshot">
                    <img src="images/replay-dashboard.png" alt="Dropbox Replay Dashboard" class="screenshot">
                    <img src="images/adobe.png" alt="Dropbox Replay Adobe Premiere Pro Integration" class="screenshot">
                    <a href="https://www.figma.com/design/d5CbuljSDTZtR68xSVIq0D/Replay-Organization---Sharing?node-id=4642-34267&t=bA8j4MOX5PLF816o-1" target="_blank" rel="noopener noreferrer" class="figma-link-large"><img src="images/figma-link-large.png" alt="Retire" class="screenshot"></a>
                </div>
            </div>
        </section>

        <section class="project">
            <h2 class="project-title">John Hancock Financial</h2>
            <p class="project-description">
                Twine.com was an incubated B2C product targeted at millenial couples to save and invest together toward their goals. I led customer and product discovery to define and ship a differentiated IRA product while meeting fiduciary and compliance requirements.
            </p>
            <div class="project-tags">
                <span class="tag">2018</span>
                <span class="tag">B2C</span>
                <span class="tag">0→1</span>
                <span class="tag">Mobile</span>
                <span class="tag">PM</span>
            </div>
            <div class="screenshot-container horizontal-scroll">
                <div class="screenshot-scroll-wrapper">
                    <img src="images/retirement.png" alt="Retire" class="screenshot">
                    <img src="images/compounding.png" alt="Compounding" class="screenshot">
                    <a href="https://www.figma.com/design/T9LAEuVii4bXgCjU1Mw07PZx/Retirement-%E2%80%94-IRA-01-30-2019?node-id=0-6514&t=rr9kgXbNlNuyVqsW-1" target="_blank" rel="noopener noreferrer" class="figma-link"><img src="images/figma-link.png" alt="Retire" class="screenshot"></a>
                    <img src="images/why-ira.png" alt="Why IRA" class="screenshot">
                    <img src="images/eligibility.png" alt="Eligibility" class="screenshot">
                    <img src="images/emergency.png" alt="Emergency" class="screenshot">
                    <img src="images/guidance.png" alt="Guidance" class="screenshot">
                    <img src="images/congrats.png" alt="Congrats" class="screenshot">
                </div>
            </div>
        </section>

        <section class="project">
            <h2 class="project-title">Pulley.com</h2>
            <p class="project-description">
                I initiated a navigation and information architecture project, gained strategic consensus on design recommendations, and wrote and shipped the code to production—customers loved it.
            </p>
            <div class="project-tags">
                <span class="tag">2024</span>
                <span class="tag">B2B</span>
                <span class="tag">Design systems</span>
                <span class="tag">Engineering</span>
            </div>
            <div class="screenshot-container horizontal-scroll">
                <div class="screenshot-scroll-wrapper">
                    <img src="images/pull-request.png" alt="Pulley.com Pull Request" class="screenshot">
                    <img src="images/pulley-nav.png" alt="Pulley.com navigation redesign" class="screenshot">
                    <a href="https://www.figma.com/design/O46ZkO9uERZQFqU3jxx9VB/Nav-redesign-Sept-2024?node-id=1462-10616&t=CpVfu5Y2ON1USvbZ-1" target="_blank" rel="noopener noreferrer" class="figma-link-large"><img src="images/figma-link-large.png" alt="Retire" class="screenshot"></a>
                </div>
            </div>
        </section>

    </main>
    <script>
        const hero = document.querySelector('.hero');
        const name = document.querySelector('.name');
        const nameNav = document.querySelector('.name-nav');
        const nav = document.querySelector('.nav');
        const profilePicture = document.querySelector('.profile-picture');
        const triangleSection = document.querySelector('.triangle-section');
        const triangleContainer = document.querySelector('.triangle-container');
        const triangleLabelProduct = document.querySelector('.triangle-label-top');
        const triangleLabelDesign = document.querySelector('.triangle-label-bottom-left');
        const triangleLabelEngineering = document.querySelector('.triangle-label-bottom-right');
        const triangleLabelBuilder = document.querySelector('.triangle-label-center');
        
        // Calculate initial font size based on viewport width
        // At 2540px viewport width, font size should be 377px
        const referenceViewportWidth = 2540;
        const referenceFontSize = 377;
        const minViewportWidth = 768; // Minimum viewport width for scaling
        const minFontSize = 64; // Minimum font size (from responsive CSS)
        
        function calculateInitialFontSize() {
            const viewportWidth = window.innerWidth;
            if (viewportWidth >= referenceViewportWidth) {
                return referenceFontSize;
            } else if (viewportWidth <= minViewportWidth) {
                return minFontSize;
            } else {
                // Linear interpolation between minFontSize and referenceFontSize
                const ratio = (viewportWidth - minViewportWidth) / (referenceViewportWidth - minViewportWidth);
                return minFontSize + (referenceFontSize - minFontSize) * ratio;
            }
        }
        
        // Calculate initial top position based on viewport width
        // At 2540px viewport width, top should be 1262.39px
        const referenceTopPosition = 1262.39;
        
        function calculateInitialTopPosition() {
            const viewportWidth = window.innerWidth;
            if (viewportWidth >= referenceViewportWidth) {
                return referenceTopPosition;
            } else {
                // Scale proportionally based on viewport width
                const ratio = viewportWidth / referenceViewportWidth;
                return referenceTopPosition * ratio;
            }
        }
        
        // Set initial font size on page load
        const initialFontSize = calculateInitialFontSize();
        name.style.fontSize = initialFontSize + 'px';
        
        // Update font size on window resize
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                handleScroll(); // Recalculate on resize
            }, 100);
        });
        
        function handleScroll() {
            const heroRect = hero.getBoundingClientRect();
            const navRect = nav.getBoundingClientRect();
            const triangleRect = triangleSection.getBoundingClientRect();
            const triangleContainerRect = triangleContainer.getBoundingClientRect();
            const viewportHeight = window.innerHeight;
            
            // Calculate the name's current position (140px from bottom of hero)
            const nameYPosition = heroRect.bottom - 140;
            
            // Nav center position (where name should end up)
            const navCenterY = navRect.top + (navRect.height / 2);
            const navCenterX = navRect.left + (navRect.width / 2);
            
            // Calculate distance from name to nav center
            const distanceToNav = nameYPosition - navCenterY;
            
            // Font size animation: starts when hero bottom reaches viewport bottom
            // Completes when name is still 200px away from nav (before snapping)
            const fontSizeAnimationStart = viewportHeight; // Hero bottom at viewport bottom
            const fontSizeAnimationEnd = navCenterY + 200; // 200px before nav
            
            let fontSizeProgress = 0;
            if (heroRect.bottom <= viewportHeight && nameYPosition > fontSizeAnimationEnd) {
                // During font size animation
                fontSizeProgress = 1 - ((nameYPosition - fontSizeAnimationEnd) / (fontSizeAnimationStart - fontSizeAnimationEnd));
            } else if (nameYPosition <= fontSizeAnimationEnd) {
                // Font size animation complete
                fontSizeProgress = 1;
            }
            fontSizeProgress = Math.max(0, Math.min(1, fontSizeProgress));
            
            // Position animation: starts when name is close to nav (100px away)
            // Snaps into place when it reaches nav
            const positionAnimationStartDistance = 100;
            const positionAnimationEndDistance = 0;
            
            let positionProgress = 0;
            let nameInNav = false;
            
            if (distanceToNav <= positionAnimationStartDistance && distanceToNav > positionAnimationEndDistance) {
                // During position animation
                positionProgress = 1 - ((distanceToNav - positionAnimationEndDistance) / (positionAnimationStartDistance - positionAnimationEndDistance));
            } else if (distanceToNav <= positionAnimationEndDistance) {
                // Position animation complete - name has reached nav
                positionProgress = 1;
                nameInNav = true;
            }
            
            // Interpolate font size between initialFontSize and 24px (based on fontSizeProgress only)
            const currentInitialFontSize = calculateInitialFontSize();
            const fontSize = currentInitialFontSize - (fontSizeProgress * (currentInitialFontSize - 24));
            
            if (nameInNav) {
                // Name is in nav - hide original, show nav version, snap into place
                name.style.opacity = '0';
                name.style.pointerEvents = 'none';
                nameNav.classList.add('visible');
                // Font size is already at 24px from fontSizeProgress
            } else if (positionProgress > 0) {
                // Snapping into nav - position animates, font size stays at 24px
                name.style.opacity = '1';
                name.style.pointerEvents = 'auto';
                nameNav.classList.remove('visible');
                
                // Calculate current position (interpolate between current position and nav center)
                const startY = nameYPosition;
                const endY = navCenterY;
                const currentY = startY - (positionProgress * (startY - endY));
                
                const startX = window.innerWidth / 2; // Original center position
                const endX = navCenterX;
                const currentX = startX + (positionProgress * (endX - startX));
                
                name.style.position = 'fixed';
                name.style.top = currentY + 'px';
                name.style.left = currentX + 'px';
                name.style.transform = 'translate(-50%, -50%)';
                name.style.fontSize = '24px'; // Already at final size
                name.style.zIndex = '1001';
            } else {
                // Always use fixed positioning to prevent flicker
                // Calculate position based on hero's current position
                name.style.opacity = '1';
                name.style.pointerEvents = 'auto';
                nameNav.classList.remove('visible');
                
                // Keep name in fixed position matching its natural position
                name.style.position = 'fixed';
                name.style.top = nameYPosition + 'px';
                name.style.left = (window.innerWidth / 2) + 'px';
                name.style.transform = 'translate(-50%, -50%)';
                name.style.fontSize = fontSize + 'px'; // Animate font size from the start
                name.style.zIndex = '1001';
            }
            
            // Profile picture animation - always in triangle container
            // Calculate triangle positions in viewport coordinates
            const triangleTop = triangleRect.top;
            const triangleCenterY = triangleContainerRect.top + (triangleContainerRect.height / 2);
            
            // Profile picture should be centered in viewport on page load
            const stickyViewportY = viewportHeight * 0.5; // Center of viewport for initial positioning
            
            // Snap threshold - triangle section snaps when it reaches this lower position
            // This positions the triangle section closer to bottom when snapping occurs
            const snapThresholdY = viewportHeight * 0.65; // Lower in viewport (closer to bottom)
            const triangleHasReachedStickyPosition = triangleCenterY <= snapThresholdY;
            
            // Check if profile photo has entered the top of the triangle
            // The photo enters when triangle top reaches or passes the sticky position
            const photoHasEnteredTriangle = triangleTop <= stickyViewportY;
            
            if (!triangleHasReachedStickyPosition) {
                // Keep profile picture fixed at center of viewport
                profilePicture.style.position = 'fixed';
                profilePicture.style.top = stickyViewportY + 'px';
                profilePicture.style.left = '50%';
                profilePicture.style.transform = 'translate(-50%, -50%)';
                profilePicture.style.zIndex = '50';
                
                // Show labels when photo enters triangle top
                if (photoHasEnteredTriangle) {
                    triangleLabelProduct.style.opacity = 1;
                    triangleLabelDesign.style.opacity = 1;
                    triangleLabelEngineering.style.opacity = 1;
                    // Don't show "Principal Product Builder" yet - only when photo is fully inside triangle
                    triangleLabelBuilder.style.opacity = 0;
                } else {
                    triangleLabelProduct.style.opacity = 0;
                    triangleLabelDesign.style.opacity = 0;
                    triangleLabelEngineering.style.opacity = 0;
                    triangleLabelBuilder.style.opacity = 0;
                }
            } else {
                // Triangle center has reached the sticky position - stop being sticky and position in triangle
                profilePicture.style.position = 'absolute';
                profilePicture.style.top = '60%';
                profilePicture.style.left = '50%';
                profilePicture.style.transform = 'translate(-50%, -50%)';
                profilePicture.style.zIndex = '10';
                // Keep labels visible (photo is now in triangle)
                triangleLabelProduct.style.opacity = 1;
                triangleLabelDesign.style.opacity = 1;
                triangleLabelEngineering.style.opacity = 1;
                // Show "Principal Product Builder" label (photo is inside triangle)
                triangleLabelBuilder.style.opacity = 1;
            }
            
        }
        
        window.addEventListener('scroll', handleScroll, { passive: true });
        handleScroll(); // Initial check
        
        // Dots animation on page load
        function createDotsAnimation() {
            const overlay = document.getElementById('dots-overlay');
            const profilePicture = document.querySelector('.profile-picture');
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            
            // Get the actual position of the profile picture (it's positioned by handleScroll)
            // Wait a couple frames to ensure positioning is complete and browser has rendered
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    const rect = profilePicture.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    const imageSize = rect.width; // Profile picture is 90px x 90px
                    
                    // Load image and sample it to create dots
                    const img = new Image();
                    // Try to set crossOrigin, but handle if it fails
                    try {
                        img.crossOrigin = 'anonymous';
                    } catch(e) {
                        // If crossOrigin fails, continue without it
                    }
                    
                    img.onload = function() {
                        createDotsFromImage(overlay, profilePicture, viewportWidth, viewportHeight, centerX, centerY, imageSize, img);
                    };
                    img.onerror = function() {
                        // If image fails to load, try without crossOrigin
                        const img2 = new Image();
                        img2.onload = function() {
                            createDotsFromImage(overlay, profilePicture, viewportWidth, viewportHeight, centerX, centerY, imageSize, img2);
                        };
                        img2.src = profilePicture.src;
                    };
                    img.src = profilePicture.src;
                });
            });
        }
        
        function createDotsFromImage(overlay, profilePicture, viewportWidth, viewportHeight, centerX, centerY, imageSize, img) {
            // Create canvas to sample image
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = imageSize;
            canvas.height = imageSize;
            ctx.drawImage(img, 0, 0, imageSize, imageSize);
            
            // Sample image data - use a grid that matches the image
            const sampleSize = 2; // Sample every 2 pixels for better detail
            const dots = [];
            
            try {
                const imageData = ctx.getImageData(0, 0, imageSize, imageSize);
                const data = imageData.data;
                
                // Calculate grid positions
                const halfSize = imageSize / 2;
                const startX = centerX - halfSize;
                const startY = centerY - halfSize;
                
                // Sample pixels and create dot data
                for (let y = 0; y < imageSize; y += sampleSize) {
                    for (let x = 0; x < imageSize; x += sampleSize) {
                        const idx = (y * imageSize + x) * 4;
                        const r = data[idx];
                        const g = data[idx + 1];
                        const b = data[idx + 2];
                        const a = data[idx + 3];
                        
                        // Skip transparent or very transparent pixels
                        if (a < 30) continue;
                        
                        // Convert to grayscale
                        const gray = Math.round(0.299 * r + 0.587 * g + 0.114 * b);
                        const brightness = gray / 255;
                        
                        // Create dots for all pixels (removed contrast filter for better image representation)
                        dots.push({
                            x: startX + x + sampleSize / 2, // Center dot in sampled area
                            y: startY + y + sampleSize / 2,
                            brightness: brightness,
                            size: 1.5 + brightness * 2.5 // Darker = smaller (1.5-2px), lighter = larger (up to 4px)
                        });
                    }
                }
            } catch(e) {
                // If we can't read image data (CORS issue), create a simple grid pattern
                const gridSize = 6;
                const halfSize = imageSize / 2;
                const startX = centerX - halfSize;
                const startY = centerY - halfSize;
                
                for (let y = 0; y < imageSize; y += gridSize) {
                    for (let x = 0; x < imageSize; x += gridSize) {
                        dots.push({
                            x: startX + x + gridSize / 2,
                            y: startY + y + gridSize / 2,
                            brightness: 0.5,
                            size: 3
                        });
                    }
                }
            }
            
            // Edges for starting positions
            const edges = ['top', 'bottom', 'left', 'right'];
            
            // Create dots
            dots.forEach((dotData, index) => {
                const dot = document.createElement('div');
                dot.className = 'dot';
                
                // Size based on brightness
                const size = dotData.size;
                dot.style.width = size + 'px';
                dot.style.height = size + 'px';
                
                // Grayscale color based on brightness
                const grayValue = Math.floor(dotData.brightness * 255);
                dot.style.backgroundColor = `rgb(${grayValue}, ${grayValue}, ${grayValue})`;
                
                // Deterministic edge assignment - distribute dots evenly across edges
                const edgeIndex = index % edges.length;
                const edge = edges[edgeIndex];
                
                // Deterministic start position based on index
                // Distribute dots evenly along each edge
                const dotsPerEdge = Math.ceil(dots.length / edges.length);
                const positionInEdge = Math.floor(index / edges.length);
                const normalizedPosition = dotsPerEdge > 1 ? positionInEdge / (dotsPerEdge - 1) : 0;
                
                let startX, startY;
                
                // Calculate start position based on edge (deterministic)
                switch(edge) {
                    case 'top':
                        // Top edge: y = 0, x = evenly distributed across width
                        startX = normalizedPosition * viewportWidth;
                        startY = 0;
                        break;
                    case 'bottom':
                        // Bottom edge: y = viewportHeight, x = evenly distributed across width
                        startX = normalizedPosition * viewportWidth;
                        startY = viewportHeight;
                        break;
                    case 'left':
                        // Left edge: x = 0, y = evenly distributed across height
                        startX = 0;
                        startY = normalizedPosition * viewportHeight;
                        break;
                    case 'right':
                        // Right edge: x = viewportWidth, y = evenly distributed across height
                        startX = viewportWidth;
                        startY = normalizedPosition * viewportHeight;
                        break;
                }
                
                // End position (exact pixel position)
                const endX = dotData.x;
                const endY = dotData.y;
                
                // Set initial position (position dot center at start position)
                const startPosX = startX - size / 2;
                const startPosY = startY - size / 2;
                dot.style.left = startPosX + 'px';
                dot.style.top = startPosY + 'px';
                dot.style.opacity = '0';
                
                overlay.appendChild(dot);
                
                // Deterministic timing - fixed duration, evenly staggered delays
                const delay = (index / dots.length) * 0.4; // Spread over 400ms
                const duration = 2.0; // Fixed duration instead of random
                
                // Calculate final position (position dot center at end position)
                const finalPosX = endX - size / 2;
                const finalPosY = endY - size / 2;
                
                // Calculate translation needed
                const translateX = finalPosX - startPosX;
                const translateY = finalPosY - startPosY;
                
                // Use requestAnimationFrame with performance.now() for consistent timing
                const startTime = performance.now();
                const targetDelay = delay * 1000;
                
                function animateDot() {
                    const elapsed = performance.now() - startTime;
                    if (elapsed >= targetDelay) {
                        dot.style.transition = `transform ${duration}s cubic-bezier(0.4, 0, 0.2, 1), opacity ${duration * 0.2}s ease-out`;
                        dot.style.opacity = '1';
                        
                        requestAnimationFrame(() => {
                            dot.style.transform = `translate(${translateX}px, ${translateY}px)`;
                        });
                    } else {
                        requestAnimationFrame(animateDot);
                    }
                }
                
                animateDot();
            });
            
            // Calculate when animation completes (max delay + duration)
            const maxDelay = 0.4;
            const maxDuration = 2.0; // Updated to match fixed duration
            const animationCompleteTime = (maxDelay + maxDuration) * 1000;
            
            // Show profile picture and remove dots immediately when animation completes
            setTimeout(() => {
                // Remove all dots immediately
                overlay.style.opacity = '0';
                overlay.style.transition = 'opacity 0.1s ease-out';
                
                // Show profile picture
                profilePicture.style.visibility = 'visible';
                profilePicture.style.transition = 'opacity 0.3s ease-in';
                profilePicture.style.opacity = '1';
                profilePicture.classList.remove('initial-load');
                
                // Remove overlay after fade
                setTimeout(() => {
                    overlay.remove();
                }, 100);
            }, animationCompleteTime);
        }
        
        // Start animation when page loads
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', createDotsAnimation);
        } else {
            createDotsAnimation();
        }
        
        // Video play button functionality
        const video = document.getElementById('nerdy-video');
        const playButton = document.getElementById('video-play-button');
        const placeholder = document.getElementById('video-placeholder');
        
        if (video && playButton && placeholder) {
            playButton.addEventListener('click', () => {
                // Hide placeholder and show video
                placeholder.style.display = 'none';
                video.style.display = 'block';
                video.play();
                playButton.classList.add('hidden');
            });
            
            video.addEventListener('play', () => {
                playButton.classList.add('hidden');
            });
            
            video.addEventListener('pause', () => {
                playButton.classList.remove('hidden');
            });
            
            video.addEventListener('ended', () => {
                playButton.classList.remove('hidden');
            });
        }
        
        // Audio player functionality
        const tuttleAudio = document.getElementById('tuttle-audio');
        const audioPlayButton = document.getElementById('audio-play-button');
        const audioResetButton = document.getElementById('audio-reset-button');
        const audioTimeDisplay = document.getElementById('audio-time');
        
        if (tuttleAudio && audioPlayButton && audioResetButton && audioTimeDisplay) {
            // Format time as MM:SS
            function formatTime(seconds) {
                if (isNaN(seconds) || !isFinite(seconds)) return '0:00';
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            }
            
            // Update time display
            function updateTimeDisplay() {
                const current = tuttleAudio.currentTime || 0;
                const duration = tuttleAudio.duration || 0;
                audioTimeDisplay.textContent = `${formatTime(current)}/${formatTime(duration)}`;
            }
            
            // Update reset button state based on playback progress
            function updateResetButton() {
                if (tuttleAudio.currentTime > 0) {
                    audioResetButton.disabled = false;
                } else {
                    audioResetButton.disabled = true;
                }
            }
            
            // Initialize time display when metadata loads
            tuttleAudio.addEventListener('loadedmetadata', () => {
                updateTimeDisplay();
                updateResetButton();
            });
            
            // Update time display during playback
            tuttleAudio.addEventListener('timeupdate', () => {
                updateTimeDisplay();
                updateResetButton();
            });
            
            // Handle play/pause button click
            audioPlayButton.addEventListener('click', () => {
                if (tuttleAudio.paused) {
                    tuttleAudio.play();
                    audioPlayButton.classList.add('playing');
                } else {
                    tuttleAudio.pause();
                    audioPlayButton.classList.remove('playing');
                }
            });
            
            // Handle reset button click
            audioResetButton.addEventListener('click', () => {
                if (!audioResetButton.disabled) {
                    tuttleAudio.currentTime = 0;
                    tuttleAudio.pause();
                    audioPlayButton.classList.remove('playing');
                    updateTimeDisplay();
                    updateResetButton();
                }
            });
            
            // Update button state when audio ends
            tuttleAudio.addEventListener('ended', () => {
                audioPlayButton.classList.remove('playing');
                updateTimeDisplay();
                updateResetButton();
            });
            
            // Update button state on pause
            tuttleAudio.addEventListener('pause', () => {
                audioPlayButton.classList.remove('playing');
            });
            
            // Update button state on play
            tuttleAudio.addEventListener('play', () => {
                audioPlayButton.classList.add('playing');
            });
        }
        
        // Login tooltip close functionality
        const loginTooltip = document.getElementById('login-tooltip');
        const tooltipClose = document.getElementById('tooltip-close');
        
        if (loginTooltip && tooltipClose) {
            tooltipClose.addEventListener('click', () => {
                loginTooltip.classList.add('hidden');
            });
        }
        
    </script>
</body>
</html>

